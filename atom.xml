<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhiXingHeYi</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.depu.online/"/>
  <updated>2016-09-02T15:12:28.000Z</updated>
  <id>http://www.depu.online/</id>
  
  <author>
    <name>Depu Lai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序专题(七)——算法总结</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%B8%83-%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-七-——算法总结/</id>
    <published>2016-09-02T11:55:21.000Z</published>
    <updated>2016-09-02T15:12:28.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(六)——计数排序、桶排序和基数排序</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E5%85%AD-%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序/</id>
    <published>2016-09-02T11:53:51.000Z</published>
    <updated>2016-09-03T08:54:33.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(五)——堆排序</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%BA%94-%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-五-——堆排序/</id>
    <published>2016-09-02T11:50:46.000Z</published>
    <updated>2016-09-03T10:23:26.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;生活的秘密在于······用一个烦恼代替另一个烦恼。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——查尔斯·M.舒尔茨&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节主要和大家讨论一下堆排序,尽管大家对于堆这种数据结构和它在排序上的应用已经非常熟悉,但是用变治策略的新眼光来观察堆排序,我们还是仍有所收获的。&lt;br&gt;变治法主要分为两个阶段工作的。首先,在”变”的截断,处于某种原因,把问题的实例变得容易求解,然后在”治”的阶段,对实例进行求解。根据对问题实例的变换方式,变治思想有3种主要类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 变换为同样问题的一个更简单或者更方便的实例——称之为&lt;strong&gt;实例化简&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(2) 变换为同样实例的不同表现——称之为&lt;strong&gt;改变表现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(3) 变换为另一个问题的实例,这种问题的算法是已知的——称之为&lt;strong&gt;问题化简&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;unstable sort&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter size-full wp-image-51210&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/300.gif&quot; alt=&quot;堆排序&quot; width=&quot;280&quot; height=&quot;214&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;br&gt;﻿1.堆在内存中的表现形式是以数组的形式存储&lt;br&gt;2.堆是一个完全二叉树&lt;br&gt;建堆：建堆的过程就是一个反复筛选的过程&lt;br&gt;1.每次都插到数组的末端，形成一个完全二叉树；&lt;br&gt;2.从最后一个非终端节点开始，直到第一个节点为止（只和子节点比较）；&lt;br&gt;删除堆：&lt;br&gt;1.每次都是删除第一个；&lt;br&gt;2.然后最后一个数字补进来；&lt;br&gt;3.然后调整堆&lt;br&gt;调整堆：&lt;br&gt;1.每次都是与最小的儿子进行交换；&lt;br&gt;2.每次都是从倒数第一个非终端节点开始调整；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1）创建一个堆H[0..n-1]&lt;/p&gt;
&lt;p&gt;2）把堆首（最大值）和堆尾互换&lt;/p&gt;
&lt;p&gt;3）把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置&lt;/p&gt;
&lt;p&gt;4） 重复步骤2，直到堆的尺寸为1&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//1.下标计算[为与程序对应，下标从0开始]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Parent(i):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return i/2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Left(i):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 2*i+1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Right(i):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return 2*i+2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//2.使下标i元素为根的的子树成为最大堆&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MAX_HEAPIFY(A,i):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;l&amp;lt;——Left(i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;r&amp;lt;——Right(i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if l&amp;lt;length(A) and A[l]&amp;gt;A[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then largest&amp;lt;——l&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    else largest&amp;lt;——i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if r&amp;lt;length(A) and A[r]&amp;gt;A[largest]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then largest&amp;lt;——r&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if largest != i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then exchange A[i] &amp;lt;——&amp;gt; A[largest]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MAX_HEAPIFY(A,largest)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//3.最大堆的建立,将数组A编译成一个最大堆&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BUILD_MAX_HEAP(A):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    heapsize[A]&amp;lt;——length[A]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for i &amp;lt;—— length[A]/2+1  to 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MAX_HEAPIFY(A,i)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//4.堆排序&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;HEAP_SORT(A):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    BUILD_MAX_HEAP(A)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for i&amp;lt;——length[A]-1 to 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        do exchange A[1] &amp;lt;——&amp;gt;  A[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        length[A]&amp;lt;—— length[A]-1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        MAX_HEAPIFY(A,0)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度:&lt;br&gt;堆排序的时间，主要由&lt;strong&gt;建立初始堆&lt;/strong&gt;和&lt;strong&gt;反复堆调整&lt;/strong&gt;这两部分的时间开销构成，堆排序的时间复杂度不依赖于特定的输入,在任何情况下,时间复杂度为&lt;strong&gt;$$Ο(nlogn)$$&lt;/strong&gt; 。&lt;br&gt;重新调整堆的时间复杂度为O(logN)，共N – 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)，二者相加还是O(N &lt;em&gt; logN)。故堆排序的时间复杂度为O(N &lt;/em&gt; logN)。&lt;br&gt;如果从底部最后的父节点开始建堆，那么我们可以大概算一下： 假如有N个节点，那么高度为H=logN，最后一层每个父节点最多只需要下调1次，倒数第二层最多只需要下调2次，顶点最多需要下调H次，而最后一层父节点共有2^(H-1)个,倒数第二层公有2^(H-2),顶点只有1(2^0)个，所以总共的时间复杂度为s = 1 &lt;em&gt; 2^(H-1) + 2 &lt;/em&gt; 2^(H-2) + … + (H-1) &lt;em&gt; 2^1 + H &lt;/em&gt; 2^0 将H代入后s= 2N - 2 - log2(N)，近似的最坏建堆时间复杂度就是O(N) 注意不是O(logN)，重新调整堆的时间复杂度才是O(logN)。重新进行保持堆特性为O(logN)，因此O(N)+O(NlogN)&lt;/p&gt;
&lt;p&gt;空间复杂度:&lt;/p&gt;
&lt;h2 id=&quot;堆排序是一种内部排序-不需要额外的辅助空间-空间复杂度为-O-1&quot;&gt;&lt;a href=&quot;#堆排序是一种内部排序-不需要额外的辅助空间-空间复杂度为-O-1&quot; class=&quot;headerlink&quot; title=&quot;堆排序是一种内部排序,不需要额外的辅助空间,空间复杂度为$$O(1)$$&quot;&gt;&lt;/a&gt;堆排序是一种内部排序,不需要额外的辅助空间,空间复杂度为&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;堆排序非常适合于求解TOP K问题,如对于一个网络游戏,从海量用户中实时获取前十名分数最高的玩家。这个时候可以考虑堆排序，因为每次排序的结果就是找到当前堆中的最大/最小值。因此完成需求的时间复杂度为m*O(logN)。当我们需要找到常数级的最大/最小值时，往往堆排序是我们应该最先考虑的&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆是一颗近似完全二叉树,它的键都满足父母优势要求(大顶堆或小顶堆)。虽然定义为二叉树,但一般用数组来实现堆。堆结构是堆排序和优先队列高效实现的基础。&lt;/li&gt;
&lt;li&gt;堆排序在理论上是一种重要的排序算法,其基本思路是,在排列好好堆中的数组元素后,再从剩余的堆中连续删除最大(或最小)的元素。在任何情况下,算法的时间复杂度为O(nlogn)。其和归并排序的时间效率属于同一类,而与后者不同的是,堆排序是一种内部排序(在位排序),不需要额外的辅助空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZhiXingHeYiApple/Sort_Topics/blob/master/SortTopics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;查看堆排序的具体实现代码&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(四)——快速排序</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E5%9B%9B-%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-四-——快速排序/</id>
    <published>2016-09-02T11:50:26.000Z</published>
    <updated>2016-09-03T09:12:23.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;缘夫天下之大，非一人之所能治，而分治之以群工。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——黄宗羲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人不论在祈祷什么，他总是祈祷着一个奇迹的降临。任何祷辞都不外是这样的意思：“伟大的上帝呵，请使二乘二不等于四吧。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——伊万·屠格涅夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一节我们介绍了归并排序,本节我们将重点讲解以下快速排序。其也是采用分治策略的算法,但它不像归并排序那样是按照元素数组在数组中的位置对它进行划分,快速排序是按照元素的值对其进行划分操作的。快速排序通过划分操作使得基准元左侧的元素都小于等于它,而右侧的元素都大于等于它(基准元)。&lt;/p&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;Out-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;Unstable sort&lt;/font&gt;&lt;br&gt;&lt;img class=&quot;aligncenter size-full wp-image-51209&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/299.gif&quot; alt=&quot;快速排序&quot; width=&quot;280&quot; height=&quot;214&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(三)——归并排序</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%B8%89-%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-三-——归并排序/</id>
    <published>2016-09-02T11:50:09.000Z</published>
    <updated>2016-09-03T09:23:22.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;缘夫天下之大，非一人之所能治，而分治之以群工。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——黄宗羲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人不论在祈祷什么，他总是祈祷着一个奇迹的降临。任何祷辞都不外是这样的意思：“伟大的上帝呵，请使二乘二不等于四吧。。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——伊万·屠格涅夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分治法可能是最著名的通用算法设计技术了。很多非常有效的算法实际上就是这个通用算法的特殊实现。分治法是按照以下方案工作的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 将一个问题划分成同一类型的若干个子问题,子问题最好规模相同。&lt;/li&gt;
&lt;li&gt;(2) 对这些子问题求解(通常采用递归方式,但当问题规模小到一定程度后,有时会利用另一算法)&lt;/li&gt;
&lt;li&gt;(3) 如果有必要的话,合并这些子问题的解,以得到原始问题的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节要介绍的归并排序,就是成功应用分治策略的一个完美例子。对于一个需要排序的数组A[0..n-1],归并排序把它一分为二,得到两个子数组并对子数组递归排序,然后把这两个排好序的子数组合并为一个有序数组。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;Out-place sort&lt;/font&gt;，&lt;font color=&quot;red&quot;&gt;stable sort&lt;/font&gt;。&lt;br&gt;&lt;img class=&quot;aligncenter size-full wp-image-51208&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/298.gif&quot; alt=&quot;归并排序&quot; width=&quot;280&quot; height=&quot;237&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;
﻿&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。用分治策略解决问题分为三步：&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;分解、解决、合并&lt;/strong&gt;&lt;/font&gt;。也即：将原问题划分成n个规模较小而结构与原问题相似的子问题； 递归地解决这些子问题，然后再合并其结果，得到原问题的解。此处n=2&lt;br&gt;基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复步骤3直到某一指针达到序列尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/2016/09/02/排序专题-三-——归并排序/sort_algorithm03_1.png&quot; alt=&quot;sort_algorithm03_1.png&quot; title=&quot;&quot;&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//合并排序伪代码(使用哨兵)：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;merge(A,p,q,r):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    n1 &amp;lt;—— q-p+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    n2 &amp;lt;—— r-q&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    create &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt; L[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n1] and R[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n2]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &amp;lt;—— &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to n1&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; L[i] &amp;lt;—— A[p+i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &amp;lt;—— &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to n2&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; R[j] &amp;lt;—— A[q+j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    L[n1] &amp;lt;—— +∞&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    R[n2] &amp;lt;—— +∞&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i &amp;lt;—— &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j &amp;lt;—— &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; k i &amp;lt;—— p to r&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; L[i]&amp;lt;=R[j]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            then A[k]  &amp;lt;—— L[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 i &amp;lt;—— i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; A[k] &amp;lt;—— R[j]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 j &amp;lt;—— j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通过调用merge完成排序：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;merge_sort(A,p,r)：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p&amp;lt;r then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       q &amp;lt;—— [(p+r)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;//向下取整&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       merge_sort(A,p,q) &lt;span class=&quot;comment&quot;&gt;//分治&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       merge_sort(A,q+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,r)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       merge(A,p,q,r)    &lt;span class=&quot;comment&quot;&gt;//合并结果&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;时间复杂度：&lt;br&gt;假设Divide需要f(n)时间，Conquer分解为b个子问题，且子问题大小为a，Combine需要g(n)时间，则递归式为：&lt;br&gt;T(n)=bT(n/a)+f(n)+g(n)&lt;br&gt;如归并排序，Divide的步骤为m=(p+q)/2，因此为O(1)，Combine步骤为merge()函数，Conquer步骤为分解为2个子问题，子问题大小为n/2，因此：&lt;br&gt;归并排序的递归式：T(n)=2T(n/2)+O(n)&lt;br&gt;归并排序的效率是比较高的,且不依赖于特定的输入，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N&lt;em&gt;logN)。因为归并排序每次都是在相邻的数据中进行操作，尽管归并排序在O(N&lt;/em&gt;logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）平均渐进复杂度是一样的,但是归并排序的系数比快排大,所以归并排序的效率较差一些,其显著优点在于稳定性。&lt;/p&gt;
&lt;p&gt;空间复杂度:&lt;br&gt;当待排序的是一个数组(顺序存储结构)时,归并排序是一种外排序(Out-place sort)，需要很多额外的空间,空间复杂度为&lt;strong&gt;$$O(n)$$&lt;/strong&gt;。而当待排序的数据是一个链表时,此时并不需要额外的存储空间(关键在于链表结点指针的重新组织)。具体实现代码如下(此时空间复杂度为&lt;strong&gt;O(1)&lt;/strong&gt;):&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Solution &amp;#123;&lt;span class=&quot;comment&quot;&gt;/* 链表归并排序 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeLists&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( ListNode * &amp;amp;head1, ListNode *head2 )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 链表1的头指针应引用传递（合并后的新链表会赋值给它） */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( head1 == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			head1 = head2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		ListNode *HEAD = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ListNode( &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		HEAD-&amp;gt;next = head1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		ListNode *cur1 = head1, *pre1 = HEAD, *cur2 = head2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( cur1 &amp;amp;&amp;amp; cur2 )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( cur2-&amp;gt;val &amp;lt; cur1-&amp;gt;val )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				pre1-&amp;gt;next	= cur2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				pre1		= pre1-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				cur2		= cur2-&amp;gt;next; &lt;span class=&quot;comment&quot;&gt;/* 这句要放在下面这行代码之前 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				pre1-&amp;gt;next	= cur1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				pre1	= cur1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				cur1	= cur1-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 此时pre1指向链表一尾部 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( cur2 )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			pre1-&amp;gt;next = cur2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		head1 = HEAD-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 归并排序（分治策略） */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( ListNode*head )&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* 区间左闭右开 */&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( head-&amp;gt;next == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;/* 利用快慢指针确定中间位置，并断开链表进行分治 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		ListNode *fast = head, *slow = head, *pre = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, *list1, *list2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ( fast )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			pre	= slow;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			slow	= slow-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( fast-&amp;gt;next )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				fast = fast-&amp;gt;next-&amp;gt;next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				fast = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( pre )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			pre-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		list1	= mergeSort( head );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		list2	= mergeSort( slow );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 合并操作 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		mergeLists( list1, list2 );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(list1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;ListNode *&lt;span class=&quot;title&quot;&gt;sortList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;( ListNode *head )&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		 * in O(n log n) time using constant space complexity.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		 * 由于需要O(nlogn)时间复杂度，所以只能考虑归并排序和堆排序，快速排序最好情况下才能达到O(nlogn)，最坏情况下为O(n^2)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		 *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         * 由于需要常数空间进行排序，所以只能考虑插入排序，选择排序，（冒泡排序，快速排序），堆排序,归并排序（链表时，无须辅助存储空间，数组时，需要额外空间）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         * 综上所述，由于链表不容易建堆进行排序，所以只能选择归并排序了&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( head == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; || head-&amp;gt;next == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; ) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(head);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(mergeSort( head ) );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;归并算法的改进思路&quot;&gt;&lt;a href=&quot;#归并算法的改进思路&quot; class=&quot;headerlink&quot; title=&quot;归并算法的改进思路&quot;&gt;&lt;/a&gt;归并算法的改进思路&lt;/h2&gt;&lt;p&gt;当我们采用递归方式实现归并算法时,对子问题没有必要分解的太细,这样会很大程度上增加递归函数调用的深度,严重影响算法效率。为了改进算法效率,我们可以把上一节中讲解过的插入排序考虑进来,将二者结合,可以有效改进算法性能。我们可以在递归分解数组使其长度变为k时，用插入排序解决子数组排序，因为插入排序适合对小数组排序。此时算法复杂度为O(nk+nlg(n/k)) ，当k=O(lgn)时，复杂度为O(nlgn)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;归并排序是一种分治排序算法。在任何情况下,算法的时间复杂度都为O(NlogN),其键值比较次数非常接近于理论上的最小值(基于比较操作的排序算法的理论下界为O(NlogN))。&lt;/li&gt;
&lt;li&gt;归并排序的主要缺点是对于数组排序,需要相当大的额外存储空间,其显著优点在于稳定性。归并排序又称为多路合并排序,非常适合对存放在二级存储空间的文件进行排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZhiXingHeYiApple/Sort_Topics/blob/master/SortTopics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;查看归并排序的具体实现代码&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;缘夫天下之大，非一人之所能治，而分治之以群工。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——黄宗羲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个人不论在祈祷什么，他总是祈祷着一个奇迹的降临。任何祷辞都不外是这样的意思：“伟大的上帝呵，请使二乘二不等于四吧。。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——伊万·屠格涅夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分治法可能是最著名的通用算法设计技术了。很多非常有效的算法实际上就是这个通用算法的特殊实现。分治法是按照以下方案工作的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 将一个问题划分成同一类型的若干个子问题,子问题最好规模相同。&lt;/li&gt;
&lt;li&gt;(2) 对这些子问题求解(通常采用递归方式,但当问题规模小到一定程度后,有时会利用另一算法)&lt;/li&gt;
&lt;li&gt;(3) 如果有必要的话,合并这些子问题的解,以得到原始问题的答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节要介绍的归并排序,就是成功应用分治策略的一个完美例子。对于一个需要排序的数组A[0..n-1],归并排序把它一分为二,得到两个子数组并对子数组递归排序,然后把这两个排好序的子数组合并为一个有序数组。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=red&gt;Out-place sort&lt;/font&gt;，&lt;font color=red&gt;stable sort&lt;/font&gt;。&lt;br&gt;&lt;img class=&quot;aligncenter size-full wp-image-51208&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/298.gif&quot; alt=&quot;归并排序&quot; width=&quot;280&quot; height=&quot;237&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;
﻿&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。用分治策略解决问题分为三步：&lt;font color=red&gt;&lt;strong&gt;分解、解决、合并&lt;/strong&gt;&lt;/font&gt;。也即：将原问题划分成n个规模较小而结构与原问题相似的子问题； 递归地解决这些子问题，然后再合并其结果，得到原问题的解。此处n=2&lt;br&gt;基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复步骤3直到某一指针达到序列尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(二)——插入排序和希尔排序</title>
    <link href="http://www.depu.online/2016/09/02/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%BA%8C-%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序/</id>
    <published>2016-09-02T11:46:40.000Z</published>
    <updated>2016-09-03T09:06:32.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;普卢塔克说，萨特斯为了告诉他的士兵坚忍和智慧比蛮力更重要的道理，把两匹马带到他们面前，然后让两个人拔光马的尾毛。一个人是魁梧的大力士，他用力地拔了又拔，但一点效果也没有；另一个人是一个精美的、长相矫捷的裁缝，他微笑着，每次拔掉一根毛，很快就把尾巴拔得光秃秃的。!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——科巴姆·布鲁尔&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/09/02/排序专题-二-——插入排序和希尔排序/sort_algorithm02_1.jpg&quot; alt=&quot;sort_algorithm02_1.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;减治技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。一旦建立这种关系,我们既可以从顶至下,也可以从底至上地来利用该关系。其中自顶向下会自然导致出递归算法,而自底向上版本往往是迭代实现(该方法又叫增量法)。&lt;br&gt;减治法主要表现为3种主要变化形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减去一个常量&lt;/li&gt;
&lt;li&gt;减去一个常量因子&lt;/li&gt;
&lt;li&gt;减去可变的规模&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节要讲述的直接插入排序和希尔排序,本质上都是”插入排序”。插入排序算法在一定程度上体现了减治技术在算法中的应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;stable sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;适合于小数组排序&lt;/font&gt;&lt;br&gt;&lt;img class=&quot;alignnone&quot; src=&quot;http://cricode.qiniudn.com/insert-sort.gif&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;180&quot;&gt;&lt;br&gt;思考这样一个问题,假设当我们对较小数组A[0..n-2]排序的问题已经解决了,得到一个大小为n-1的有序数组: A[0]&amp;lt;=…&amp;lt;=A[n-2]。如何利用这个较小规模的解,并将元素A[n-1]考虑进来,来得到原问题的解呢?&lt;br&gt;很显然,就像我们平时玩扑克牌时对手里的扑克牌进行排序整理的方式相同,我们要做的就是在这些有序的元素中为A[n-1]找到一个合适的位置,然后把它插入到那里。一般来说,我们从左往右扫描这个有序的子数组,直到遇到第一个小于等于A[n-1]的元素,然后把A[n-1]插在该元素后面。这也是插入法名字的由来。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//非递归版本插入排序(自底向上)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;InsertionSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用插入排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    key&amp;lt;- A[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j&amp;lt;- i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; j&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; and key&amp;lt;A[j] &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;lt;- A[j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      j&amp;lt;- j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;lt;- key;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//递归版本插入排序(自顶向下)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Recursive_InsertionSort(A[0..n-1],p,q)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if p&amp;lt;q then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Recursive_InsertionSort(A,p,q-1)   //递归将A[p..q-1]进行排序&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Insert(A,p,q-1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Insert(A[0..n-1],p,q)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  key&amp;lt;- A[q+1]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  j&amp;lt;- q&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  while j&amp;gt;=0 and key&amp;lt;A[j] do&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    A[j+1]&amp;lt;- A[j]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j&amp;lt;- j-1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  A[j+1]&amp;lt;- key&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度:&lt;br&gt;插入排序是基于比较操作的排序算法,所以算法分析时,该算法的基本操作是键值比较。&lt;br&gt;最优复杂度：当输入数组就是排好序的时候，需要n-1次比较操作,复杂度为&lt;strong&gt;$$O(n)$$&lt;/strong&gt;，而快速排序在这种情况下会产生O(n^2)的复杂度。&lt;br&gt;最差复杂度：其实插入排序的复杂度和逆序对的个数一样，当数组倒序时，逆序对的个数为n(n-1)/2，因此插入排序最坏复杂度为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;。&lt;br&gt;平均复杂度: 对于随机序列的数组,插入排序的平均比较次数是降序数组的一半,也就是说需要约(n^2)/4次比较操作,复杂度为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;&lt;br&gt;直接插入排序的平均性能比最差性能快一倍,以及遇到基本有序的数组时表现出的优异性能,使得插入排序领先于它在基本排序算法领域的主要竞争对手 —— 选择排序和冒泡排序。&lt;/p&gt;
&lt;p&gt;空间复杂度：&lt;br&gt;直接插入排序是一种内部排序(In-place sort),所以不需要额外的辅助空间，其空间复杂度为&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;unstable sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;适合于较大的数组排序&lt;/font&gt;&lt;br&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://cricode.qiniudn.com/shellsort_anim.gif&quot; alt=&quot;&quot; width=&quot;277&quot; height=&quot;344&quot;&gt;&lt;br&gt;希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。&lt;/p&gt;
&lt;p&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1)插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率&lt;/li&gt;
&lt;li&gt;(2)但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希尔排序的基本思想是：先将整个待排序的记录序列&lt;font color=&quot;red&quot;&gt;分割成为若干子序列分别进行直接插入排序&lt;/font&gt;，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。&lt;/p&gt;
&lt;p&gt;直接插入排序也适用于链式存储结构；&lt;font color=&quot;red&quot;&gt;希尔排序不适用于链式结构&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;对于希尔排序来说，步长为&lt;font color=&quot;red&quot;&gt; 1， 4， 13， 40， 121&lt;/font&gt;的效率是最高的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1）选择一个增量序列t1，t2，…，tk，其中ti&amp;gt;tj，tk=1；&lt;/p&gt;
&lt;p&gt;2）按增量序列个数k，对序列进行k 趟排序；   增量序列gap的取法必须满足：&lt;font color=&quot;red&quot;&gt;&lt;em&gt;最后一个步长必须是&lt;/em&gt; 1&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度：&lt;br&gt;希尔排序的算法时间性能依赖于特定的输入。最好的情况下,数组已经按照升序排列了,此时时间复杂度为&lt;strong&gt;$$O(n)$$&lt;/strong&gt;，而当输入数组为一个严格递减的数组时,对其升序排序,达到最差时间复杂度为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;。除了这两种极端情况外,其它大部分数组排序的平均时间复杂度约为&lt;strong&gt;O(n^1.3)&lt;/strong&gt;&lt;br&gt;空间复杂度：&lt;br&gt;希尔排序是对直接插入排序的扩展可改进,也是一种内部排序(In-place sort),所以不需要额外的辅助空间，其空间复杂度为&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;减治法是一种一般性的算法设计技术,该方法有3种主要变化形式:(1)减一个常量(例如插入排序);(2)减一个常因子(例如二分查找);(3)减可变规模&lt;/li&gt;
&lt;li&gt;直接插入排序是减一技术在排序问题上的运用。无论在平均情况下还是在最差情况下,它都是一个O(n^2)的算法,但在平均情况下的效率大约要比最差情况快一倍。该算法很适合于小规模的且基本有序的数组。&lt;/li&gt;
&lt;li&gt;希尔排序是插入排序的扩展优化版本,适用于较大规模的数组,尽管其和插入排序一样都是内部排序,不需要额外的存储控件,但它却牺牲了稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZhiXingHeYiApple/Sort_Topics/blob/master/SortTopics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;查看插入排序和希尔排序的具体实现代码&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;普卢塔克说，萨特斯为了告诉他的士兵坚忍和智慧比蛮力更重要的道理，把两匹马带到他们面前，然后让两个人拔光马的尾毛。一个人是魁梧的大力士，他用力地拔了又拔，但一点效果也没有；另一个人是一个精美的、长相矫捷的裁缝，他微笑着，每次拔掉一根毛，很快就把尾巴拔得光秃秃的。!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——科巴姆·布鲁尔&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/09/02/排序专题-二-——插入排序和希尔排序/sort_algorithm02_1.jpg&quot; alt=&quot;sort_algorithm02_1.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;减治技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。一旦建立这种关系,我们既可以从顶至下,也可以从底至上地来利用该关系。其中自顶向下会自然导致出递归算法,而自底向上版本往往是迭代实现(该方法又叫增量法)。&lt;br&gt;减治法主要表现为3种主要变化形式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减去一个常量&lt;/li&gt;
&lt;li&gt;减去一个常量因子&lt;/li&gt;
&lt;li&gt;减去可变的规模&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节要讲述的直接插入排序和希尔排序,本质上都是”插入排序”。插入排序算法在一定程度上体现了减治技术在算法中的应用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=red&gt;In-place sort&lt;/font&gt;、&lt;font color=red&gt;stable sort&lt;/font&gt;、&lt;font color=red&gt;适合于小数组排序&lt;/font&gt;&lt;br&gt;&lt;img class=&quot;alignnone&quot; src=&quot;http://cricode.qiniudn.com/insert-sort.gif&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;180&quot;&gt;&lt;br&gt;思考这样一个问题,假设当我们对较小数组A[0..n-2]排序的问题已经解决了,得到一个大小为n-1的有序数组: A[0]&amp;lt;=…&amp;lt;=A[n-2]。如何利用这个较小规模的解,并将元素A[n-1]考虑进来,来得到原问题的解呢?&lt;br&gt;很显然,就像我们平时玩扑克牌时对手里的扑克牌进行排序整理的方式相同,我们要做的就是在这些有序的元素中为A[n-1]找到一个合适的位置,然后把它插入到那里。一般来说,我们从左往右扫描这个有序的子数组,直到遇到第一个小于等于A[n-1]的元素,然后把A[n-1]插在该元素后面。这也是插入法名字的由来。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//非递归版本插入排序(自底向上)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;InsertionSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用插入排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    key&amp;lt;- A[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j&amp;lt;- i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; j&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; and key&amp;lt;A[j] &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;lt;- A[j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      j&amp;lt;- j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;lt;- key;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//递归版本插入排序(自顶向下)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Recursive_InsertionSort(A[0..n-1],p,q)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if p&amp;lt;q then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Recursive_InsertionSort(A,p,q-1)   //递归将A[p..q-1]进行排序&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Insert(A,p,q-1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Insert(A[0..n-1],p,q)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  key&amp;lt;- A[q+1]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  j&amp;lt;- q&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  while j&amp;gt;=0 and key&amp;lt;A[j] do&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    A[j+1]&amp;lt;- A[j]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    j&amp;lt;- j-1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  A[j+1]&amp;lt;- key&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>如何写伪代码</title>
    <link href="http://www.depu.online/2016/07/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%BC%AA%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.depu.online/2016/07/19/如何写伪代码/</id>
    <published>2016-07-19T08:57:19.000Z</published>
    <updated>2016-07-19T09:39:35.000Z</updated>
    
    <content type="html">&lt;p&gt;看到这个标题，你肯定会很不屑！在真实世界中，你可能掌握了多门编程语言，如swfit，python，java，c++，javascript等等。直接用这些语言来写代码，实现逻辑不就行了嘛！伪代码感觉就没啥用武之地，平时也不怎么接触和使用。但是在IT企业求职或面试过程中，在短短的一二十分钟内，HR想要考察你的专业技能，肯定不可能给你提供真实的编程环境，让你编写代码。通常情况下，是给你纸和笔，让你用伪代码来写出代码的逻辑。这个时候，你可能和我一样，就会有疑问了，具体的伪代码格式该怎么写？这个时候，你可以用你最擅长的一门编程语言的格式来写，但个人认为，除非特殊情况，否则最好用伪代码来写，一方面简洁明了，另一方面HR未必就懂你写的那个语言（通常HR也都是搞技术的，不会有太大问题）。所以最好还是了解一些伪代码的格式。&lt;br&gt;通常伪代码是介于自然语言和计算机编程语言之间的一种算法描述语言。其具有简洁明了易懂的特点。但具体的格式并没有非常严格的标准和规范。所以以下总结的伪代码格式，是参考个人认为比较权威的《算法导论》这本书。&lt;/p&gt;
&lt;p&gt;（1）赋值用箭头“←” 或”:=”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i←&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;//for、while、if 后面的条件语句都不用加括号&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; XXXXX      &lt;span class=&quot;comment&quot;&gt;//for后面必定要紧跟缩进的do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       XXXXX&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（3）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; time&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;  xxxxx    &lt;span class=&quot;comment&quot;&gt;//while后面必定要紧跟缩进的do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        xxxxx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（4）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; xxxx    &lt;span class=&quot;comment&quot;&gt;//else 和 then 要在对齐&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（5）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx   &lt;span class=&quot;comment&quot;&gt;//if 后面必定跟上then，else后面不用跟then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;elseif i=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         yyyy&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;  xxxx             &lt;span class=&quot;comment&quot;&gt;//else 跟在elseif 的 then 对齐&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//也可以用如下方式:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; Then&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        XXXXXX&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        XXXXXX&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（6）elseif 要合并。&lt;/p&gt;
&lt;p&gt;（7）&lt;u&gt;同一嵌套等级的语句要对齐&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;（8）定义变量的语句不用写出来，但必须在注释中给出&lt;/p&gt;
&lt;p&gt;（9）函数的伪代码格式例子为：search（A，name）        &lt;strong&gt;//参数类型可以不给出，但必须在注释中说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（10）写完的伪代码最后必须在每行伪代码前加上序号&lt;/p&gt;
&lt;p&gt;（10）对于常用的一些操作(不是该算法的核心部分),可以利用单词意思来描述就行了,如交换操作,可以使用swap XX and XX(或者exchange)。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题，你肯定会很不屑！在真实世界中，你可能掌握了多门编程语言，如swfit，python，java，c++，javascript等等。直接用这些语言来写代码，实现逻辑不就行了嘛！伪代码感觉就没啥用武之地，平时也不怎么接触和使用。但是在IT企业求职或面试过程中，在短短的一二十分钟内，HR想要考察你的专业技能，肯定不可能给你提供真实的编程环境，让你编写代码。通常情况下，是给你纸和笔，让你用伪代码来写出代码的逻辑。这个时候，你可能和我一样，就会有疑问了，具体的伪代码格式该怎么写？这个时候，你可以用你最擅长的一门编程语言的格式来写，但个人认为，除非特殊情况，否则最好用伪代码来写，一方面简洁明了，另一方面HR未必就懂你写的那个语言（通常HR也都是搞技术的，不会有太大问题）。所以最好还是了解一些伪代码的格式。&lt;br&gt;通常伪代码是介于自然语言和计算机编程语言之间的一种算法描述语言。其具有简洁明了易懂的特点。但具体的格式并没有非常严格的标准和规范。所以以下总结的伪代码格式，是参考个人认为比较权威的《算法导论》这本书。&lt;/p&gt;
&lt;p&gt;（1）赋值用箭头“←” 或”:=”&lt;br&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(一)——选择排序与冒泡排序</title>
    <link href="http://www.depu.online/2016/07/18/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%B8%80-%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序/</id>
    <published>2016-07-18T06:22:45.000Z</published>
    <updated>2016-09-02T15:09:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;把事情做好,常常是浪费时间!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——罗伯特·伯恩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪不断，理还乱，是离愁，别是一番滋味在心头。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——李清照&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/07/18/排序专题-一-——选择排序和冒泡排序/sort_algorithm01.png&quot; alt=&quot;sort_algorithm01.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;现实世界中，纷繁凌乱的表象常常掩盖事物的规律和本质。为了去掉这层表象，我们不得不对事物重新组织，让其变的有序。在探索的过程中，人们开发出了几十种排序算法，广泛应用于人们的生活和生产实践中。大家过去或多或少都接触或了解过其中的一些算法，如果是这样，请你暂时忘记它们，以初学者的姿态问自己一个问题：“在只看结果，不考虑其他约束的情况下，解决排序问题最直接了当的方法是什么？” 对于这个问题的答案恐怕是智者见智，仁者见仁。也许你并不同意我的观点，但选择排序和冒泡排序绝对是两个有力的候选者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;蛮力法，经常又被称呼为穷举法或暴力拆解法。是一种简单直接地解决问题的方法，常直接基于问题的描述和所涉及的概念定义。&lt;br&gt;尽管“巧妙”与“高效”这两个高大上的词汇与“蛮力法”这个穷屌丝往往搭不上边。但是我们不应该忽略这个穷屌丝（屌丝也有完美逆袭的一天）的存在，其作为一种重要的算法设计策略的地位是无法撼动的，理由如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于解决的问题类型更具一般性和普适性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虽然效率低，但仍可以解决一些小规模的问题实例。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当要解决的问题实例不多或解空间较小时，蛮力法仍可以用能够接受的速度对问题进行求解，而寻找和设计一个更高效算法所花费的代价可能是不值得的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蛮力法经常被其他一些“高富帅”的算法作为参照标杆。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为在排序算法中，选择排序和冒泡排序俨然就是蛮力法的最佳代言人。这也正是我为什么会选择这两个排序算法作为讲解排序专题的切入点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;（无需额外辅助空间），&lt;font color=&quot;red&quot;&gt;unstable sort&lt;/font&gt;（非稳定）。&lt;br&gt;&lt;img class=&quot;aligncenter size-full wp-image-51206&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/296.gif&quot; alt=&quot;选择排序&quot; width=&quot;288&quot; height=&quot;288&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;br&gt;1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置&lt;/p&gt;
&lt;p&gt;2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;/p&gt;
&lt;p&gt;3）重复第二步，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;举例(红色标记的数为每轮迭代找到的最小数)&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt;  &amp;emsp;89&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;17&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;29&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;34&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;46&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;67&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;89&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;89&amp;emsp;&amp;emsp;92&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;SelectionSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用选择排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    min&amp;lt;- i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j] &amp;lt; A[min] then min&amp;lt;- j&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    swap A[i] and A[min]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注：最外层循环只需要进行n-1轮迭代。显而易见，n-1轮迭代后A[1…n-1]包含了A中最小的i-1个元素，且已排序，因此A[n]中的元素是最大的，因此A[1…n]已排序。&lt;br&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度：&lt;br&gt;在选择排序算法中的基本操作是比较操作&lt;code&gt;A[j] &amp;lt; A[min]&lt;/code&gt;，其执行次数仅仅取决于数组的规模,并不依赖于特定的输入。所以其时间复杂度始终为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;&lt;br&gt;空间复杂度：&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;br&gt;选择排序算法键的的交换次数为&lt;code&gt;&lt;font color=&quot;red&quot;&gt;n-1&lt;/font&gt;&lt;/code&gt;次（每轮迭代执行一次交换），这个特性使得选择排序优于其它许多时间复杂度也是O(n^2)的排序算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;stable sort&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter size-full wp-image-51207&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/297.gif&quot; alt=&quot;冒泡排序&quot; width=&quot;280&quot; height=&quot;237&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。之所以叫冒泡排序，是因为在相邻元素不断两两交换的过程中，较小的元素会慢慢浮到数列的前端，而每轮迭代，都会将所有未排序元素中最大的元素会沉到数列的尾部，这一过程非常类似于水中的气泡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1）比较相邻的元素。如果需要调整，就交换它们。&lt;/p&gt;
&lt;p&gt;2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/p&gt;
&lt;p&gt;3）针对所有的元素重复以上的步骤，&lt;font color=&quot;red&quot;&gt;除了最后一个&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;4）持续每次对越来越少的元素重复上面的步骤，&lt;font color=&quot;red&quot;&gt;直到没有任何一对数字需要比较&lt;/font&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to i &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度：&lt;br&gt;未改进版本的冒泡排序键值比较次数对于任何输入规模为n的数组都是相同的，但键的交换次数却取决于特定的输入数组。最坏情况下，遇到降序的数组，交换次数与键值比较次数相同。因此我们应该把键值比较作为冒泡排序的基本操作。算法复杂度为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;&lt;br&gt;空间复杂度：&lt;br&gt;和选择排序一样，冒泡排序也不需要额外的辅助空间，其空间复杂度为&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序法的改进&quot;&gt;&lt;a href=&quot;#冒泡排序法的改进&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序法的改进&quot;&gt;&lt;/a&gt;冒泡排序法的改进&lt;/h3&gt;&lt;p&gt;在应用蛮力法时常常会遇到这种情况，即经过适度的努力后，我们能够对算法的第一个版本进行一定的改良。让我们回顾前面讲过的选择排序和冒泡排序，分析伪代码，你会发现这两个算法的实现都需要两层循环嵌套，而且它们在每轮迭代中都是彼此独立的，正如一个头脑简单，空有蛮力的人一个劲儿地往终点冲刺，而忽略了沿途的风景，同时也忽略了捷径。简单的冒泡排序正是犯了这样的错误，而没有充分激发出自己的潜能。具体来说吧！在冒泡排序过程中，在某轮迭代中，如果对列表比较一遍后发现没有进行元素交换时，说明列表已经是有序的了，可以终止这个算法了。&lt;br&gt;具体的方式主要有3种（尽管都大同小异，本质上就一个策略,及时终止,不做无用功）。&lt;/p&gt;
&lt;p&gt;(1). 加一个标志位flag，当某一趟冒泡排序没有元素交换时，则冒泡结束，元素已经有序，可以有效的减少冒泡次数。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用改进冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; flag==&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; then &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  flag&amp;lt;- &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to i &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   	flag&amp;lt;- &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2). 保留“犯罪现场”，记录每轮迭代过程中，最后进行交换的元素的下标（&lt;font color=&quot;red&quot;&gt;该元素之后的所有元素已经是有序的了&lt;/font&gt;）。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用改进的冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  lastSwap&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; lastSwap &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to lastSwap &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		        lastSwap&amp;lt;- j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//记录最后一次交换的位置&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(3). 双向冒泡排序（又称鸡尾酒排序）。该方式从低到高然后从高到低去比较序列里的每个元素。这种方式可以得到比基本冒泡排序稍微好一点的效能（通过分别保存每轮迭代过程，高位置最后一次交换的位置，以及低位置最后一次交换发生的位置）。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用双向冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    up&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; low&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; low&amp;lt;up &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- low to up&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//从低到高扫描&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[i]&amp;gt;A[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  then swap A[i] and A[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		       up&amp;lt;- i  &lt;span class=&quot;comment&quot;&gt;//记录最后一个交换的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- up downto low+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//从高到低扫描&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[i]&amp;gt;A[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  then swap A[i] and A[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		       low&amp;lt;- i   &lt;span class=&quot;comment&quot;&gt;//记录最后一个交换的位置&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上的这些改进使得在最好情况下（数组已经有序）复杂度可以降到&lt;strong&gt;O(n)&lt;/strong&gt;。虽然对于某些输入，可能运行的比较快，但在最坏情况和平均情况下，这些算法仍然属于&lt;strong&gt;O(n^2)&lt;/strong&gt;。实际上，即使在初等排序中，冒泡排序法也不是一个好的选择。如果不是它有一个形象而又容易记住的名字。我们可能不会对它有太多了解。但不管怎样，我们刚刚学到的内容是非常重要的！这两种基本的排序算法常常被调侃为算法界的Hello World！在IT企业的面试环节中，经常被HR拿出来考查你是否具备基本的算法基础，为了不被HR鄙视，你懂的！好好理解和掌握它们吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;蛮力法可以快速地得到一个算法，此算法在一些情况下可以通过适度的努力来提升它的性能。&lt;/li&gt;
&lt;li&gt;选择排序和冒泡排序，归结起来就6个字“循环，比较，交换”&lt;/li&gt;
&lt;li&gt;选择排序和冒泡排序&lt;u&gt;都属于内部排序&lt;/u&gt;，无需额外存储空间；而&lt;u&gt;冒泡排序是稳定排序，选择排序是不稳定的&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ZhiXingHeYiApple/Sort_Topics/blob/master/SortTopics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;查看冒泡和选择排序的具体实现代码&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(一)——选择排序和冒泡排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-二-——插入排序和希尔排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(二)——插入排序和希尔排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-三-——归并排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——归并排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-四-——快速排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(四)——快速排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-五-——堆排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——堆排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-六-——计数排序、桶排序和基数排序&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(三)——计数排序、桶排序和基数排序&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.depu.online/2016/09/02/排序专题-七-——算法总结&quot;&gt;&lt;font color=&quot;#FF6100&quot;&gt;排序专题(七)——算法总结&lt;/font&gt;&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;把事情做好,常常是浪费时间!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——罗伯特·伯恩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪不断，理还乱，是离愁，别是一番滋味在心头。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——李清照&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/07/18/排序专题-一-——选择排序和冒泡排序/sort_algorithm01.png&quot; alt=&quot;sort_algorithm01.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;现实世界中，纷繁凌乱的表象常常掩盖事物的规律和本质。为了去掉这层表象，我们不得不对事物重新组织，让其变的有序。在探索的过程中，人们开发出了几十种排序算法，广泛应用于人们的生活和生产实践中。大家过去或多或少都接触或了解过其中的一些算法，如果是这样，请你暂时忘记它们，以初学者的姿态问自己一个问题：“在只看结果，不考虑其他约束的情况下，解决排序问题最直接了当的方法是什么？” 对于这个问题的答案恐怕是智者见智，仁者见仁。也许你并不同意我的观点，但选择排序和冒泡排序绝对是两个有力的候选者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;蛮力法，经常又被称呼为穷举法或暴力拆解法。是一种简单直接地解决问题的方法，常直接基于问题的描述和所涉及的概念定义。&lt;br&gt;尽管“巧妙”与“高效”这两个高大上的词汇与“蛮力法”这个穷屌丝往往搭不上边。但是我们不应该忽略这个穷屌丝（屌丝也有完美逆袭的一天）的存在，其作为一种重要的算法设计策略的地位是无法撼动的，理由如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于解决的问题类型更具一般性和普适性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虽然效率低，但仍可以解决一些小规模的问题实例。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当要解决的问题实例不多或解空间较小时，蛮力法仍可以用能够接受的速度对问题进行求解，而寻找和设计一个更高效算法所花费的代价可能是不值得的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蛮力法经常被其他一些“高富帅”的算法作为参照标杆。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为在排序算法中，选择排序和冒泡排序俨然就是蛮力法的最佳代言人。这也正是我为什么会选择这两个排序算法作为讲解排序专题的切入点。&lt;br&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
</feed>
