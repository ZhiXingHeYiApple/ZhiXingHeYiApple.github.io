<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhiXingHeYi</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.depu.online/"/>
  <updated>2016-07-19T09:39:35.000Z</updated>
  <id>http://www.depu.online/</id>
  
  <author>
    <name>Depu Lai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何写伪代码</title>
    <link href="http://www.depu.online/2016/07/19/%E5%A6%82%E4%BD%95%E5%86%99%E4%BC%AA%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.depu.online/2016/07/19/如何写伪代码/</id>
    <published>2016-07-19T08:57:19.000Z</published>
    <updated>2016-07-19T09:39:35.000Z</updated>
    
    <content type="html">&lt;p&gt;看到这个标题，你肯定会很不屑！在真实世界中，你可能掌握了多门编程语言，如swfit，python，java，c++，javascript等等。直接用这些语言来写代码，实现逻辑不就行了嘛！伪代码感觉就没啥用武之地，平时也不怎么接触和使用。但是在IT企业求职或面试过程中，在短短的一二十分钟内，HR想要考察你的专业技能，肯定不可能给你提供真实的编程环境，让你编写代码。通常情况下，是给你纸和笔，让你用伪代码来写出代码的逻辑。这个时候，你可能和我一样，就会有疑问了，具体的伪代码格式该怎么写？这个时候，你可以用你最擅长的一门编程语言的格式来写，但个人认为，除非特殊情况，否则最好用伪代码来写，一方面简洁明了，另一方面HR未必就懂你写的那个语言（通常HR也都是搞技术的，不会有太大问题）。所以最好还是了解一些伪代码的格式。&lt;br&gt;通常伪代码是介于自然语言和计算机编程语言之间的一种算法描述语言。其具有简洁明了易懂的特点。但具体的格式并没有非常严格的标准和规范。所以以下总结的伪代码格式，是参考个人认为比较权威的《算法导论》这本书。&lt;/p&gt;
&lt;p&gt;（1）赋值用箭头“←” 或”:=”&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i←&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;//for、while、if 后面的条件语句都不用加括号&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; XXXXX      &lt;span class=&quot;comment&quot;&gt;//for后面必定要紧跟缩进的do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       XXXXX&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（3）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; time&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;  xxxxx    &lt;span class=&quot;comment&quot;&gt;//while后面必定要紧跟缩进的do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        xxxxx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（4）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; xxxx    &lt;span class=&quot;comment&quot;&gt;//else 和 then 要在对齐&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（5）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx   &lt;span class=&quot;comment&quot;&gt;//if 后面必定跟上then，else后面不用跟then&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;elseif i=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    then xxxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         yyyy&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;  xxxx             &lt;span class=&quot;comment&quot;&gt;//else 跟在elseif 的 then 对齐&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//也可以用如下方式:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; Then&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        XXXXXX&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        XXXXXX&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（6）elseif 要合并。&lt;/p&gt;
&lt;p&gt;（7）&lt;u&gt;同一嵌套等级的语句要对齐&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;（8）定义变量的语句不用写出来，但必须在注释中给出&lt;/p&gt;
&lt;p&gt;（9）函数的伪代码格式例子为：search（A，name）        &lt;strong&gt;//参数类型可以不给出，但必须在注释中说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（10）写完的伪代码最后必须在每行伪代码前加上序号&lt;/p&gt;
&lt;p&gt;（10）对于常用的一些操作(不是该算法的核心部分),可以利用单词意思来描述就行了,如交换操作,可以使用swap XX and XX(或者exchange)。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题，你肯定会很不屑！在真实世界中，你可能掌握了多门编程语言，如swfit，python，java，c++，javascript等等。直接用这些语言来写代码，实现逻辑不就行了嘛！伪代码感觉就没啥用武之地，平时也不怎么接触和使用。但是在IT企业求职或面试过程中，在短短的一二十分钟内，HR想要考察你的专业技能，肯定不可能给你提供真实的编程环境，让你编写代码。通常情况下，是给你纸和笔，让你用伪代码来写出代码的逻辑。这个时候，你可能和我一样，就会有疑问了，具体的伪代码格式该怎么写？这个时候，你可以用你最擅长的一门编程语言的格式来写，但个人认为，除非特殊情况，否则最好用伪代码来写，一方面简洁明了，另一方面HR未必就懂你写的那个语言（通常HR也都是搞技术的，不会有太大问题）。所以最好还是了解一些伪代码的格式。&lt;br&gt;通常伪代码是介于自然语言和计算机编程语言之间的一种算法描述语言。其具有简洁明了易懂的特点。但具体的格式并没有非常严格的标准和规范。所以以下总结的伪代码格式，是参考个人认为比较权威的《算法导论》这本书。&lt;/p&gt;
&lt;p&gt;（1）赋值用箭头“←” 或”:=”&lt;br&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序专题(一)——选择排序与冒泡排序</title>
    <link href="http://www.depu.online/2016/07/18/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98-%E4%B8%80-%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.depu.online/2016/07/18/排序专题-一-——选择排序和冒泡排序/</id>
    <published>2016-07-18T06:22:45.000Z</published>
    <updated>2016-07-19T13:05:00.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;把事情做好,常常是浪费时间!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——罗伯特·伯恩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪不断，理还乱，是离愁，别是一番滋味在心头。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——李清照&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/07/18/排序专题-一-——选择排序和冒泡排序/sort_algorithm01.png&quot; alt=&quot;sort_algorithm01.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;现实世界中，纷繁凌乱的表象常常掩盖事物的规律和本质。为了去掉这层表象，我们不得不对事物重新组织，让其变的有序。在探索的过程中，人们开发出了几十种排序算法，广泛应用于人们的生活和生产实践中。大家过去或多或少都接触或了解过其中的一些算法，如果是这样，请你暂时忘记它们，以初学者的姿态问自己一个问题：“在只看结果，不考虑其他约束的情况下，解决排序问题最直接了当的方法是什么？” 对于这个问题的答案恐怕是智者见智，仁者见仁。也许你并不同意我的观点，但选择排序和冒泡排序绝对是两个有力的候选者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;蛮力法，经常又被称呼为穷举法或暴力拆解法。是一种简单直接地解决问题的方法，常直接基于问题的描述和所涉及的概念定义。&lt;br&gt;尽管“巧妙”与“高效”这两个高大上的词汇与“蛮力法”这个穷屌丝往往搭不上边。但是我们不应该忽略这个穷屌丝（屌丝也有完美逆袭的一天）的存在，其作为一种重要的算法设计策略的地位是无法撼动的，理由如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于解决的问题类型更具一般性和普适性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虽然效率低，但仍可以解决一些小规模的问题实例。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当要解决的问题实例不多或解空间较小时，蛮力法仍可以用能够接受的速度对问题进行求解，而寻找和设计一个更高效算法所花费的代价可能是不值得的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蛮力法经常被其他一些“高富帅”的算法作为参照标杆。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为在排序算法中，选择排序和冒泡排序俨然就是蛮力法的最佳代言人。这也正是我为什么会选择这两个排序算法作为讲解排序专题的切入点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;（无需额外辅助空间），&lt;font color=&quot;red&quot;&gt;unstable sort&lt;/font&gt;（非稳定）。&lt;br&gt;&lt;img class=&quot;aligncenter size-full wp-image-51206&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/296.gif&quot; alt=&quot;选择排序&quot; width=&quot;288&quot; height=&quot;288&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;br&gt;1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置&lt;/p&gt;
&lt;p&gt;2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。&lt;/p&gt;
&lt;p&gt;3）重复第二步，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;举例(红色标记的数为每轮迭代找到的最小数)&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt;  &amp;emsp;89&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;17&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;29&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;67&amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;34&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;46&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;&amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;67&lt;/font&gt;&lt;/strong&gt;&amp;emsp;&amp;emsp;89&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;|&lt;/font&gt;&lt;/strong&gt; &amp;emsp;92&amp;emsp;&amp;emsp;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;89&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;17&amp;emsp;&amp;emsp;29&amp;emsp;&amp;emsp;34&amp;emsp;&amp;emsp;46&amp;emsp;&amp;emsp;67&amp;emsp;&amp;emsp;89&amp;emsp;&amp;emsp;92&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;SelectionSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用选择排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    min&amp;lt;- i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j] &amp;lt; A[min] then min&amp;lt;- j&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    swap A[i] and A[min]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注：最外层循环只需要进行n-1轮迭代。显而易见，n-1轮迭代后A[1…n-1]包含了A中最小的i-1个元素，且已排序，因此A[n]中的元素是最大的，因此A[1…n]已排序。&lt;br&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度：&lt;br&gt;在选择排序算法中的基本操作是比较操作&lt;code&gt;A[j] &amp;lt; A[min]&lt;/code&gt;，其执行次数仅仅取决于数组的规模,并不依赖于特定的输入。所以其时间复杂度始终为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;&lt;br&gt;空间复杂度：&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;br&gt;选择排序算法键的的交换次数为&lt;code&gt;&lt;font color=&quot;red&quot;&gt;n-1&lt;/font&gt;&lt;/code&gt;次（每轮迭代执行一次交换），这个特性使得选择排序优于其它许多时间复杂度也是O(n^2)的排序算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;In-place sort&lt;/font&gt;、&lt;font color=&quot;red&quot;&gt;stable sort&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;aligncenter size-full wp-image-51207&quot; src=&quot;http://www.36dsj.com/wp-content/uploads/2016/05/297.gif&quot; alt=&quot;冒泡排序&quot; width=&quot;280&quot; height=&quot;237&quot; data-tag=&quot;bdshare&quot; data-bd-imgshare-binded=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。之所以叫冒泡排序，是因为在相邻元素不断两两交换的过程中，较小的元素会慢慢浮到数列的前端，而每轮迭代，都会将所有未排序元素中最大的元素会沉到数列的尾部，这一过程非常类似于水中的气泡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1）比较相邻的元素。如果需要调整，就交换它们。&lt;/p&gt;
&lt;p&gt;2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/p&gt;
&lt;p&gt;3）针对所有的元素重复以上的步骤，&lt;font color=&quot;red&quot;&gt;除了最后一个&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;4）持续每次对越来越少的元素重复上面的步骤，&lt;font color=&quot;red&quot;&gt;直到没有任何一对数字需要比较&lt;/font&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to i &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;算法复杂度&lt;/strong&gt;：&lt;br&gt;时间复杂度：&lt;br&gt;未改进版本的冒泡排序键值比较次数对于任何输入规模为n的数组都是相同的，但键的交换次数却取决于特定的输入数组。最坏情况下，遇到降序的数组，交换次数与键值比较次数相同。因此我们应该把键值比较作为冒泡排序的基本操作。算法复杂度为&lt;strong&gt;$$O(n^2)$$&lt;/strong&gt;&lt;br&gt;空间复杂度：&lt;br&gt;和选择排序一样，冒泡排序也不需要额外的辅助空间，其空间复杂度为&lt;strong&gt;$$O(1)$$&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序法的改进&quot;&gt;&lt;a href=&quot;#冒泡排序法的改进&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序法的改进&quot;&gt;&lt;/a&gt;冒泡排序法的改进&lt;/h3&gt;&lt;p&gt;在应用蛮力法时常常会遇到这种情况，即经过适度的努力后，我们能够对算法的第一个版本进行一定的改良。让我们回顾前面讲过的选择排序和冒泡排序，分析伪代码，你会发现这两个算法的实现都需要两层循环嵌套，而且它们在每轮迭代中都是彼此独立的，正如一个头脑简单，空有蛮力的人一个劲儿地往终点冲刺，而忽略了沿途的风景，同时也忽略了捷径。简单的冒泡排序正是犯了这样的错误，而没有充分激发出自己的潜能。具体来说吧！在冒泡排序过程中，在某轮迭代中，如果对列表比较一遍后发现没有进行元素交换时，说明列表已经是有序的了，可以终止这个算法了。&lt;br&gt;具体的方式主要有3种（尽管都大同小异，本质上就一个策略,及时终止,不做无用功）。&lt;/p&gt;
&lt;p&gt;(1). 加一个标志位flag，当某一趟冒泡排序没有元素交换时，则冒泡结束，元素已经有序，可以有效的减少冒泡次数。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用改进冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt; downto &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; flag==&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; then &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  flag&amp;lt;- &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to i &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   	flag&amp;lt;- &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2). 保留“犯罪现场”，记录每轮迭代过程中，最后进行交换的元素的下标（&lt;font color=&quot;red&quot;&gt;该元素之后的所有元素已经是有序的了&lt;/font&gt;）。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用改进的冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  lastSwap&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; lastSwap &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; to lastSwap &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j]&amp;gt;A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		   then swap A[j] and A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		        lastSwap&amp;lt;- j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//记录最后一次交换的位置&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(3). 双向冒泡排序（又称鸡尾酒排序）。该方式从低到高然后从高到低去比较序列里的每个元素。这种方式可以得到比基本冒泡排序稍微好一点的效能（通过分别保存每轮迭代过程，高位置最后一次交换的位置，以及低位置最后一次交换发生的位置）。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;伪代码&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;BubbleSort(A[&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;.n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//功能：用双向冒泡排序对给定的数组进行排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输入：一个可排序数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//输出：升序排列的数组A[0..n-1]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    up&amp;lt;- n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; low&amp;lt;- &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; low&amp;lt;up &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- low to up&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//从低到高扫描&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[i]&amp;gt;A[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  then swap A[i] and A[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		       up&amp;lt;- i  &lt;span class=&quot;comment&quot;&gt;//记录最后一个交换的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i&amp;lt;- up downto low+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;//从高到低扫描&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	  	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[i]&amp;gt;A[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		  then swap A[i] and A[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		       low&amp;lt;- i   &lt;span class=&quot;comment&quot;&gt;//记录最后一个交换的位置&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上的这些改进使得在最好情况下（数组已经有序）复杂度可以降到&lt;strong&gt;O(n)&lt;/strong&gt;。虽然对于某些输入，可能运行的比较快，但在最坏情况和平均情况下，这些算法仍然属于&lt;strong&gt;O(n^2)&lt;/strong&gt;。实际上，即使在初等排序中，冒泡排序法也不是一个好的选择。如果不是它有一个形象而又容易记住的名字。我们可能不会对它有太多了解。但不管怎样，我们刚刚学到的内容是非常重要的！这两种基本的排序算法常常被调侃为算法界的Hello World！在IT企业的面试环节中，经常被HR拿出来考查你是否具备基本的算法基础，为了不被HR鄙视，你懂的！好好理解和掌握它们吧！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;蛮力法可以快速地得到一个算法，此算法在一些情况下可以通过适度的努力来提升它的性能。&lt;/li&gt;
&lt;li&gt;选择排序和冒泡排序，归结起来就6个字“循环，比较，交换”&lt;/li&gt;
&lt;li&gt;选择排序和冒泡排序&lt;u&gt;都属于内部排序&lt;/u&gt;，无需额外存储空间；而&lt;u&gt;冒泡排序是稳定排序，选择排序是不稳定的&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;把事情做好,常常是浪费时间!&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——罗伯特·伯恩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪不断，理还乱，是离愁，别是一番滋味在心头。&amp;emsp; &amp;emsp;&amp;emsp; &amp;emsp;——李清照&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2016/07/18/排序专题-一-——选择排序和冒泡排序/sort_algorithm01.png&quot; alt=&quot;sort_algorithm01.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;现实世界中，纷繁凌乱的表象常常掩盖事物的规律和本质。为了去掉这层表象，我们不得不对事物重新组织，让其变的有序。在探索的过程中，人们开发出了几十种排序算法，广泛应用于人们的生活和生产实践中。大家过去或多或少都接触或了解过其中的一些算法，如果是这样，请你暂时忘记它们，以初学者的姿态问自己一个问题：“在只看结果，不考虑其他约束的情况下，解决排序问题最直接了当的方法是什么？” 对于这个问题的答案恐怕是智者见智，仁者见仁。也许你并不同意我的观点，但选择排序和冒泡排序绝对是两个有力的候选者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;蛮力法&quot;&gt;&lt;a href=&quot;#蛮力法&quot; class=&quot;headerlink&quot; title=&quot;蛮力法&quot;&gt;&lt;/a&gt;蛮力法&lt;/h2&gt;&lt;p&gt;蛮力法，经常又被称呼为穷举法或暴力拆解法。是一种简单直接地解决问题的方法，常直接基于问题的描述和所涉及的概念定义。&lt;br&gt;尽管“巧妙”与“高效”这两个高大上的词汇与“蛮力法”这个穷屌丝往往搭不上边。但是我们不应该忽略这个穷屌丝（屌丝也有完美逆袭的一天）的存在，其作为一种重要的算法设计策略的地位是无法撼动的，理由如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于解决的问题类型更具一般性和普适性。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虽然效率低，但仍可以解决一些小规模的问题实例。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当要解决的问题实例不多或解空间较小时，蛮力法仍可以用能够接受的速度对问题进行求解，而寻找和设计一个更高效算法所花费的代价可能是不值得的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蛮力法经常被其他一些“高富帅”的算法作为参照标杆。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为在排序算法中，选择排序和冒泡排序俨然就是蛮力法的最佳代言人。这也正是我为什么会选择这两个排序算法作为讲解排序专题的切入点。&lt;br&gt;
    
    </summary>
    
      <category term="传统算法" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序专题" scheme="http://www.depu.online/categories/%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Algorithm" scheme="http://www.depu.online/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://www.depu.online/tags/Sort/"/>
    
  </entry>
  
</feed>
